
#include <libc_shims.h>
#include <malloc.h>
#include <time.h>

#include <PR/os.h>

void abort() {
  printf("abort()");

  {
    int faultCause;
    faultCause = *(int*)1;
  }
  while (1) {
  }
}

/* Simple implementation of vsprintf for systems without it.
   Highly system-dependent, but should work on most "traditional"
   implementations of stdio; newer ones should already have vsprintf.
   Written by Per Bothner of Cygnus Support.
   Based on libg++'s "form" (written by Doug Lea; dl@rocky.oswego.edu).
   Copyright (C) 1991-2018 Free Software Foundation, Inc.

This file is part of the libiberty library.  This library is free
software; you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option)
any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU CC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
02110-1301, USA.

As a special exception, if you link this library with files
compiled with a GNU compiler to produce an executable, this does not cause
the resulting executable to be covered by the GNU General Public License.
This exception does not however invalidate any other reasons why
the executable file might be covered by the GNU General Public License. */

extern int _Printf(void* (*)(void*, const char*, size_t),
                   void*,
                   const char*,
                   va_list);

static void* proutSprintf(void* s, const char* buf, size_t n) {
  /* write to string */
  return ((char*)memcpy(s, buf, n) + n);
}

int vsprintf(char* s, const char* fmt, va_list ap) {
  /* print formatted to string */
  int ans;
  ans =
      _Printf((void* (*)(void*, const char*, size_t))proutSprintf, s, fmt, ap);
  if (0 <= ans)
    s[ans] = '\0';
  return ans;
}

/* Estimate the length of the string generated by a vprintf-like
   function.  Used by vasprintf and xvasprintf.
   Copyright (C) 1994-2018 Free Software Foundation, Inc.

This file is part of the libiberty library.
Libiberty is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

Libiberty is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with libiberty; see the file COPYING.LIB.  If not, write
to the Free Software Foundation, Inc., 51 Franklin Street - Fifth
Floor, Boston, MA 02110-1301, USA.  */

int libiberty_vprintf_buffer_size(const char* format, va_list args) {
  const char* p = format;
  /* Add one to make sure that it is never zero, which might cause malloc
     to return NULL.  */
  int total_width = strlen(format) + 1;
  va_list ap;

#ifdef va_copy
  va_copy(ap, args);
#else
  memcpy((void*)&ap, (void*)&args, sizeof(va_list));
#endif

  while (*p != '\0') {
    if (*p++ == '%') {
      while (strchr("-+ #0", *p))
        ++p;
      if (*p == '*') {
        ++p;
        total_width += abs(va_arg(ap, int));
      } else
        total_width += strtoul(p, (char**)&p, 10);
      if (*p == '.') {
        ++p;
        if (*p == '*') {
          ++p;
          total_width += abs(va_arg(ap, int));
        } else
          total_width += strtoul(p, (char**)&p, 10);
      }
      while (strchr("hlL", *p))
        ++p;
      /* Should be big enough for any format specifier except %s and floats.  */
      total_width += 30;
      switch (*p) {
        case 'd':
        case 'i':
        case 'o':
        case 'u':
        case 'x':
        case 'X':
        case 'c':
          (void)va_arg(ap, int);
          break;
        case 'f':
        case 'e':
        case 'E':
        case 'g':
        case 'G':
          (void)va_arg(ap, double);
          /* Since an ieee double can have an exponent of 307, we'll
       make the buffer wide enough to cover the gross case. */
          total_width += 307;
          break;
        case 's':
          total_width += strlen(va_arg(ap, char*));
          break;
        case 'p':
        case 'n':
          (void)va_arg(ap, char*);
          break;
      }
      p++;
    }
  }
#ifdef va_copy
  va_end(ap);
#endif
  return total_width;
}

/* Like vsprintf but provides a pointer to malloc'd storage, which must
   be freed by the caller.
   Copyright (C) 1994-2020 Free Software Foundation, Inc.

This file is part of the libiberty library.
Libiberty is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

Libiberty is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with libiberty; see the file COPYING.LIB.  If not, write
to the Free Software Foundation, Inc., 51 Franklin Street - Fifth
Floor, Boston, MA 02110-1301, USA.  */

/*

@deftypefn Extension int vasprintf (char **@var{resptr}, @
  const char *@var{format}, va_list @var{args})

Like @code{vsprintf}, but instead of passing a pointer to a buffer,
you pass a pointer to a pointer.  This function will compute the size
of the buffer needed, allocate memory with @code{malloc}, and store a
pointer to the allocated memory in @code{*@var{resptr}}.  The value
returned is the same as @code{vsprintf} would return.  If memory could
not be allocated, minus one is returned and @code{NULL} is stored in
@code{*@var{resptr}}.

@end deftypefn

*/

static int int_vasprintf(char** result, const char* format, va_list args) {
  int total_width = libiberty_vprintf_buffer_size(format, args);
  *result = (char*)malloc(total_width);
  if (*result != NULL)
    return vsprintf(*result, format, args);
  else
    return -1;
}

int vasprintf(char** result, const char* format, va_list args) {
  return int_vasprintf(result, format, args);
}

/* Implement the vsnprintf function.
   Copyright (C) 2003-2020 Free Software Foundation, Inc.
   Written by Kaveh R. Ghazi <ghazi@caip.rutgers.edu>.

This file is part of the libiberty library.  This library is free
software; you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option)
any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU CC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
02110-1301, USA.

As a special exception, if you link this library with files
compiled with a GNU compiler to produce an executable, this does not cause
the resulting executable to be covered by the GNU General Public License.
This exception does not however invalidate any other reasons why
the executable file might be covered by the GNU General Public License. */

/*

@deftypefn Supplemental int vsnprintf (char *@var{buf}, size_t @var{n}, @
  const char *@var{format}, va_list @var{ap})

This function is similar to @code{vsprintf}, but it will write to
@var{buf} at most @code{@var{n}-1} bytes of text, followed by a
terminating null byte, for a total of @var{n} bytes.  On error the
return value is -1, otherwise it returns the number of characters that
would have been printed had @var{n} been sufficiently large,
regardless of the actual value of @var{n}.  Note some pre-C99 system
libraries do not implement this correctly so users cannot generally
rely on the return value if the system version of this function is
used.

@end deftypefn

*/

/* This implementation relies on a working vasprintf.  */
int vsnprintf(char* s, size_t n, const char* format, va_list ap) {
  char* buf = 0;
  int result = vasprintf(&buf, format, ap);

  if (!buf)
    return -1;
  if (result < 0) {
    free(buf);
    return -1;
  }

  result = strlen(buf);
  if (n > 0) {
    if ((long)n > result)
      memcpy(s, buf, result + 1);
    else {
      memcpy(s, buf, n - 1);
      s[n - 1] = 0;
    }
  }
  free(buf);
  return result;
}

/* Implement the snprintf function.
   Copyright (C) 2003-2020 Free Software Foundation, Inc.
   Written by Kaveh R. Ghazi <ghazi@caip.rutgers.edu>.

This file is part of the libiberty library.  This library is free
software; you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option)
any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU CC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
02110-1301, USA.

As a special exception, if you link this library with files
compiled with a GNU compiler to produce an executable, this does not cause
the resulting executable to be covered by the GNU General Public License.
This exception does not however invalidate any other reasons why
the executable file might be covered by the GNU General Public License. */

/*

@deftypefn Supplemental int snprintf (char *@var{buf}, size_t @var{n}, @
  const char *@var{format}, ...)

This function is similar to @code{sprintf}, but it will write to
@var{buf} at most @code{@var{n}-1} bytes of text, followed by a
terminating null byte, for a total of @var{n} bytes.
On error the return value is -1, otherwise it returns the number of
bytes, not including the terminating null byte, that would have been
written had @var{n} been sufficiently large, regardless of the actual
value of @var{n}.  Note some pre-C99 system libraries do not implement
this correctly so users cannot generally rely on the return value if
the system version of this function is used.

@end deftypefn

*/

int snprintf(char* s, size_t n, const char* format, ...) {
  int result;
  va_list ap;
  va_start(ap, format);
  result = vsnprintf(s, n, format, ap);
  va_end(ap);
  return result;
}

void ed64PrintfSync2(const char* fmt, ...);

int sscanf(const char* str, const char* format, ...) {
  int n;
  va_list arg_ptr;
  va_start(arg_ptr, format);

  ed64PrintfSync2("%s not implemented", __FUNCTION__);
  {
    int intentionallyCrash;
    intentionallyCrash = *(int*)1;
  }
  // TODO
  // n=vsscanf(str,format,arg_ptr);
  n = 0;
  va_end(arg_ptr);
  return n;
}

// static time_t curtime = 0;

time_t time(time_t* arg) {
  // time_t ret = curtime++;
  time_t ret = OS_CYCLES_TO_USEC(osGetTime()) / 1000000.0;
  if (arg) {
    *arg = ret;
  }
  return ret;
}

double difftime(time_t time1, time_t time2) {
  return (double)time1 - (double)time2;
}
time_t mktime(struct tm* tm) {
  return tm->tm_sec;
}
// size_t strftime (char *__restrict, size_t, const char *__restrict, const
// struct tm *__restrict);

/* seconds per day */
#define SPD 24 * 60 * 60

struct tm gmtime_static;
struct tm* gmtime(const time_t* timep) {
  struct tm* r = &gmtime_static;
  time_t work = *timep % (SPD);
  r->tm_sec = work % 60;
  work /= 60;
  r->tm_min = work % 60;
  r->tm_hour = work / 60;
  r->tm_wday = 1;
  r->tm_year = 1970;
  r->tm_yday = 1;
  r->tm_mday = 1;
  r->tm_mon = 1;
  r->tm_mday = 1;
  return r;
}

struct tm localtime_static;
struct tm* localtime(const time_t* timep) {
  struct tm* r = &localtime_static;
  time_t work = *timep % (SPD);
  r->tm_sec = work % 60;
  work /= 60;
  r->tm_min = work % 60;
  r->tm_hour = work / 60;
  r->tm_wday = 1;
  r->tm_year = 1970;
  r->tm_yday = 1;
  r->tm_mday = 1;
  r->tm_mon = 1;
  r->tm_mday = 1;
  return r;
}
// char *asctime (const struct tm *);
